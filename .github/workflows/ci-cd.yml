name: PowerShell Module CI/CD

on:
  push:
    branches: [ main, develop, feat/* ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

env:
  # Set PowerShell execution policy
  POWERSHELL_EXECUTION_POLICY: RemoteSigned

jobs:
  test:
    name: Test PowerShell Module
    runs-on: ubuntu-latest
    strategy:
      matrix:
        powershell-version: ['7.2', '7.3', '7.4']
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup PowerShell ${{ matrix.powershell-version }}
      shell: pwsh
      run: |
        # Download and install specific PowerShell version if not default
        if ('${{ matrix.powershell-version }}' -ne '7.4') {
          Write-Host "Setting up PowerShell ${{ matrix.powershell-version }}"
          # Note: GitHub runners come with PowerShell 7.4 by default
          # For other versions, you might need custom installation
        }
        $PSVersionTable
        
    - name: Install Required Modules
      shell: pwsh
      run: |
        Write-Host "ðŸ“¦ Installing PowerShell modules..." -ForegroundColor Green
        
        # Set PSGallery as trusted to avoid prompts
        Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
        
        # Install required modules
        $modules = @(
          @{ Name = 'Pester'; MinimumVersion = '5.0.0' }
          @{ Name = 'PSScriptAnalyzer'; MinimumVersion = '1.20.0' }
          @{ Name = 'platyPS'; MinimumVersion = '0.14.0' }
        )
        
        foreach ($module in $modules) {
          Write-Host "Installing $($module.Name)..." -ForegroundColor Yellow
          Install-Module @module -Force -AllowClobber -Scope CurrentUser
        }
        
        # Verify installations
        Write-Host "âœ… Installed modules:" -ForegroundColor Green
        Get-Module -ListAvailable Pester, PSScriptAnalyzer, platyPS | 
          Select-Object Name, Version | Format-Table -AutoSize
        
    - name: Import and Validate Module
      shell: pwsh
      run: |
        Write-Host "ðŸ” Importing and validating Glooko module..." -ForegroundColor Green
        
        # Test module manifest
        Write-Host "Testing module manifest..." -ForegroundColor Yellow
        $manifest = Test-ModuleManifest -Path './Glooko.psd1' -ErrorAction Stop
        Write-Host "âœ… Module manifest is valid" -ForegroundColor Green
        Write-Host "  Name: $($manifest.Name)" -ForegroundColor White
        Write-Host "  Version: $($manifest.Version)" -ForegroundColor White
        Write-Host "  Author: $($manifest.Author)" -ForegroundColor White
        
        # Import the module
        Write-Host "Importing module..." -ForegroundColor Yellow
        Import-Module './Glooko.psd1' -Force -ErrorAction Stop
        
        # Verify module import
        $module = Get-Module -Name Glooko
        if ($module) {
          Write-Host "âœ… Module imported successfully" -ForegroundColor Green
          Write-Host "  Exported Functions: $($module.ExportedFunctions.Keys -join ', ')" -ForegroundColor White
        } else {
          throw "âŒ Failed to import Glooko module"
        }
        
    - name: Run PSScriptAnalyzer
      shell: pwsh
      run: |
        Write-Host "ðŸ” Running PSScriptAnalyzer..." -ForegroundColor Green
        
        # Get all PowerShell files
        $psFiles = Get-ChildItem -Path . -Filter "*.ps1" -Recurse | 
          Where-Object { $_.FullName -notlike "*/.git/*" }
        
        Write-Host "Analyzing $($psFiles.Count) PowerShell files..." -ForegroundColor Yellow
        
        # Run analysis with custom settings if available
        $settingsPath = "./.vscode/PSScriptAnalyzerSettings.psd1"
        $analysisParams = @{
          Path = $psFiles
          Recurse = $false
        }
        
        if (Test-Path $settingsPath) {
          $analysisParams.Settings = $settingsPath
          Write-Host "Using custom PSScriptAnalyzer settings" -ForegroundColor Cyan
        }
        
        $results = Invoke-ScriptAnalyzer @analysisParams
        
        # Process results
        if ($results) {
          $errorCount = ($results | Where-Object Severity -eq 'Error').Count
          $warningCount = ($results | Where-Object Severity -eq 'Warning').Count
          $infoCount = ($results | Where-Object Severity -eq 'Information').Count
          
          Write-Host "ðŸ“Š Analysis Results:" -ForegroundColor Cyan
          Write-Host "  Errors: $errorCount" -ForegroundColor $(if($errorCount -gt 0){'Red'}else{'Green'})
          Write-Host "  Warnings: $warningCount" -ForegroundColor $(if($warningCount -gt 0){'Yellow'}else{'Green'})
          Write-Host "  Information: $infoCount" -ForegroundColor Cyan
          
          # Display detailed results
          $results | Format-Table -AutoSize
          
          # Fail if there are errors
          if ($errorCount -gt 0) {
            throw "âŒ PSScriptAnalyzer found $errorCount error(s)"
          }
          
          Write-Host "âœ… PSScriptAnalyzer passed with $warningCount warning(s)" -ForegroundColor Green
        } else {
          Write-Host "âœ… PSScriptAnalyzer found no issues" -ForegroundColor Green
        }
        
    - name: Run Pester Tests
      shell: pwsh
      run: |
        Write-Host "ðŸ§ª Running Pester tests..." -ForegroundColor Green
        
        # Configure Pester
        $pesterConfig = New-PesterConfiguration
        $pesterConfig.Run.Path = './Tests'
        $pesterConfig.Output.Verbosity = 'Detailed'
        $pesterConfig.CodeCoverage.Enabled = $true
        $pesterConfig.CodeCoverage.Path = './Public/*.ps1', './Private/*.ps1', './Glooko.psm1'
        $pesterConfig.CodeCoverage.OutputFormat = 'JaCoCo'
        $pesterConfig.CodeCoverage.OutputPath = 'coverage.xml'
        $pesterConfig.TestResult.Enabled = $true
        $pesterConfig.TestResult.OutputFormat = 'NUnitXml'
        $pesterConfig.TestResult.OutputPath = 'testResults.xml'
        
        # Run tests
        $testResults = Invoke-Pester -Configuration $pesterConfig
        
        # Process results
        Write-Host "ðŸ“Š Test Results:" -ForegroundColor Cyan
        Write-Host "  Total: $($testResults.TotalCount)" -ForegroundColor White
        Write-Host "  Passed: $($testResults.PassedCount)" -ForegroundColor $(if($testResults.PassedCount -eq $testResults.TotalCount){'Green'}else{'Yellow'})
        Write-Host "  Failed: $($testResults.FailedCount)" -ForegroundColor $(if($testResults.FailedCount -gt 0){'Red'}else{'Green'})
        Write-Host "  Skipped: $($testResults.SkippedCount)" -ForegroundColor Cyan
        
        if ($testResults.CodeCoverage) {
          $coverage = [math]::Round($testResults.CodeCoverage.CoveragePercent, 2)
          Write-Host "  Coverage: $coverage%" -ForegroundColor $(if($coverage -ge 80){'Green'}elseif($coverage -ge 60){'Yellow'}else{'Red'})
        }
        
        # Fail if tests failed
        if ($testResults.FailedCount -gt 0) {
          throw "âŒ $($testResults.FailedCount) test(s) failed"
        }
        
        Write-Host "âœ… All tests passed!" -ForegroundColor Green
        
    - name: Upload Test Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-ps${{ matrix.powershell-version }}
        path: |
          testResults.xml
          coverage.xml
        retention-days: 30
        
    - name: Upload Coverage to Codecov
      uses: codecov/codecov-action@v3
      if: matrix.powershell-version == '7.4' # Only upload coverage once
      with:
        file: ./coverage.xml
        flags: powershell
        name: codecov-umbrella
        fail_ci_if_error: false

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Security Scan
      shell: pwsh
      run: |
        Write-Host "ðŸ›¡ï¸ Running security scan..." -ForegroundColor Green
        
        # Install PSScriptAnalyzer if not available
        if (-not (Get-Module -ListAvailable PSScriptAnalyzer)) {
          Install-Module PSScriptAnalyzer -Force -Scope CurrentUser
        }
        
        # Run security-focused analysis
        $securityResults = Invoke-ScriptAnalyzer -Path . -Recurse -IncludeRule @(
          'PSAvoidUsingConvertToSecureStringWithPlainText',
          'PSAvoidUsingPlainTextForPassword', 
          'PSAvoidUsingUsernameAndPasswordParams',
          'PSAvoidUsingInvokeExpression',
          'PSAvoidGlobalVars'
        )
        
        if ($securityResults) {
          Write-Host "âš ï¸ Security issues found:" -ForegroundColor Yellow
          $securityResults | Format-Table -AutoSize
          
          $criticalIssues = $securityResults | Where-Object Severity -eq 'Error'
          if ($criticalIssues) {
            throw "âŒ Critical security issues found"
          }
        } else {
          Write-Host "âœ… No security issues found" -ForegroundColor Green
        }

  build-docs:
    name: Build Documentation
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Generate Module Documentation
      shell: pwsh
      run: |
        Write-Host "ðŸ“š Generating module documentation..." -ForegroundColor Green
        
        # Install required modules
        Install-Module platyPS -Force -Scope CurrentUser
        
        # Import the module
        Import-Module './Glooko.psd1' -Force
        
        # Create docs directory
        $docsPath = './docs'
        if (-not (Test-Path $docsPath)) {
          New-Item -ItemType Directory -Path $docsPath -Force
        }
        
        # Generate markdown help
        try {
          New-MarkdownHelp -Module Glooko -OutputFolder $docsPath -Force
          Write-Host "âœ… Documentation generated successfully" -ForegroundColor Green
          
          # List generated files
          Get-ChildItem $docsPath -Filter "*.md" | ForEach-Object {
            Write-Host "  ðŸ“„ $($_.Name)" -ForegroundColor White
          }
        } catch {
          Write-Warning "Documentation generation failed: $($_.Exception.Message)"
        }
        
    - name: Upload Documentation
      uses: actions/upload-artifact@v4
      with:
        name: module-documentation
        path: docs/
        retention-days: 90

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    if: github.ref == 'refs/heads/main' && contains(github.event.head_commit.message, '[release]')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Get Module Version
      shell: pwsh
      id: version
      run: |
        $manifest = Import-PowerShellDataFile -Path './Glooko.psd1'
        $version = $manifest.ModuleVersion
        Write-Host "Module version: $version"
        echo "version=$version" >> $env:GITHUB_OUTPUT
        
    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ steps.version.outputs.version }}
        release_name: Glooko PowerShell Module v${{ steps.version.outputs.version }}
        body: |
          ## Glooko PowerShell Module v${{ steps.version.outputs.version }}
          
          ### Features
          - CSV import functionality with first-row skipping
          - PowerShell 5.1+ and 7.x compatibility
          - Comprehensive error handling and validation
          
          ### Installation
          ```powershell
          # Download and import
          Invoke-WebRequest -Uri "https://github.com/${{ github.repository }}/archive/v${{ steps.version.outputs.version }}.zip" -OutFile "Glooko.zip"
          Expand-Archive -Path "Glooko.zip" -DestinationPath "."
          Import-Module "./Glooko-${{ steps.version.outputs.version }}/Glooko.psd1"
          ```
          
          ### Testing
          All tests pass on PowerShell 7.2, 7.3, and 7.4
          
          See [README.md](https://github.com/${{ github.repository }}/blob/v${{ steps.version.outputs.version }}/README.md) for detailed usage instructions.
        draft: false
        prerelease: false